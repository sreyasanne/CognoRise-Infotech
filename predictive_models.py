# -*- coding: utf-8 -*-
"""Predictive_Models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fANGFG1fQZBKjEaIeRf9PeAd7f-_jYgl
"""

# Data handling and visualization
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Scikit-learn modules for preprocessing and model training
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, f1_score

# XGBoost
from xgboost import XGBClassifier

# SMOTE for handling class imbalance
from imblearn.over_sampling import SMOTE

print("Libraries imported successfully!")

# Step 2: Load the Dataset
data = pd.read_csv('telco_churn.csv')
data.head()

# Step 3: Preprocess the Data
try:
    # Drop customerID column since it's not useful for prediction
    data.drop('customerID', axis=1, inplace=True)

    # Convert 'TotalCharges' to numeric and fill missing values
    data['TotalCharges'] = pd.to_numeric(data['TotalCharges'], errors='coerce')
    data['TotalCharges'].fillna(data['TotalCharges'].median(), inplace=True)

    # Encode binary categorical columns
    binary_cols = ['gender', 'Partner', 'Dependents', 'PhoneService', 'PaperlessBilling', 'Churn']
    for col in binary_cols:
        data[col] = LabelEncoder().fit_transform(data[col])

    # One-hot encode other categorical columns
    data = pd.get_dummies(data, drop_first=True)

    # Split into features and target
    X = data.drop('Churn', axis=1)
    y = data['Churn']

    # Print success message
    print("Preprocessing successful. Data is ready for model training.")

except Exception as e:
    print(f"An error occurred during preprocessing: {e}")

try:
    # Split the data into train and test sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Print success message
    print("Data splitting successful. Training and test sets are ready for model training.")

except Exception as e:
    print(f"An error occurred during data splitting: {e}")

# Step 5: Normalize the Features
try:
  scaler = StandardScaler()
  X_train = scaler.fit_transform(X_train)
  X_test = scaler.transform(X_test)
  # Print success message
  print("Feature scaling successful. Data is ready for model training.")

except Exception as e:
  print(f"An error occurred during feature scaling: {e}")

# Step 6: Handle Class Imbalance using SMOTE
try:
  smote = SMOTE(random_state=42)
  X_train_smote, y_train_smote = smote.fit_resample(X_train, y_train)
  # Print success message
  print("Class imbalance handling successful. Data is ready for model training.")

except Exception as e:
  print(f"An error occurred during class imbalance handling: {e}")

# Step 7: Train Multiple Models and Compare Performance
models = {
    'Logistic Regression': LogisticRegression(max_iter=1000),
    'Decision Tree': DecisionTreeClassifier(),
    'Random Forest': RandomForestClassifier(),
    'KNN': KNeighborsClassifier(),
    'XGBoost': XGBClassifier(use_label_encoder=False, eval_metric='logloss')
}

# Dictionary to store evaluation results
results = {}

# Train and evaluate each model
for name, model in models.items():
    try:
        # Fit the model
        model.fit(X_train_smote, y_train_smote)

        # Predict on the test set
        y_pred = model.predict(X_test)

        # Calculate metrics
        accuracy = accuracy_score(y_test, y_pred)
        f1 = f1_score(y_test, y_pred)

        # Store results
        results[name] = {
            'Accuracy': accuracy,
            'F1 Score': f1
        }

        # Print results
        print(f"Model: {name}")
        print(f"Accuracy: {accuracy:.2f}")
        print(f"F1 Score: {f1:.2f}")
        print(classification_report(y_test, y_pred))
        print('-' * 50)

    except Exception as e:
        print(f"An error occurred while evaluating {name}: {e}")

# Print a summary of results
print("Summary of results:")
results_df = pd.DataFrame(results).T
print(results_df)

# Step 9: Visualize the Results
results_df.plot(kind='bar', figsize=(10, 6), ylim=(0, 1))
plt.title('Model Performance Comparison')
plt.ylabel('Score')
plt.xticks(rotation=45)
plt.show()